package Example.Example_28;

/*
 * 쓰레드 (Thread) 란?
 * - CPU 의 작업 시간을 할당 받는 기본 단위를 의미한다. (+ 즉, 프로그램이 실행 되면 메인 쓰레드가 기본적으로
 * 할당 된다는 것을 알 수 있다.)
 *
 * 프로그램이 실행 되면 CPU 의 작업 시간을 할당 받기 위한 쓰레드가 생성 되며 이를 메인 쓰레드라고 한다. (+ 즉,
 * 쓰레드가 존재하기 때문에 CPU 에 의해서 명령문이 샐행 된다는 것을 알 수 있다.)
 *
 * 프로그램은 필요에 따라 쓰레드를 추가적으로 생성하는 것이 가능하며 이렇게 여러 쓰레드를 활용해서 프로그램을
 * 제작하는 것을 멀티 쓰레드 프로그래밍이라고 한다. (+ 즉, 쓰레드를 활용하면 여러 작업을 동시에 처리하는
 * 병렬 처리가 가능하다는 것을 의미한다.)
 *
 * 단, 오늘 날의 운영 체제는 특정 쓰레드가 CPU 의 작업 시간을 독점 할 수 없는 선점형 운영 체제이기 때문에
 * 각 쓰레드마다 CPU 를 사용하는 시간이 다르며 어떤 쓰레드가 먼저 CPU 의 작업 시간을 할당 받을 지 알 수 없다.
 * (+ 즉, 멀티 쓰레드로 제작 된 프로그램은 실행 될 때 마다 쓰레드의 실행 순서가 다르다는 것을 알 수 있다.)
 *
 * 따라서 멀티 쓰레드 프로그래밍은 쓰레드의 작업 순서를 사용자 (프로그래머가) 가 제어해야하기 때문에
 * 프로그램을 제작하는 난이도가 높다는 것을 알 수 있다. (+ 즉, 쓰레드마다 실행 시간이나 순서가 다르기 때문에
 * 문제가 발생한 부분을 찾는 것이 어렵다는 것을 알 수 있다.)
 *
 * 멀티 쓰레드 프로그래밍을 할 때 발생하는 가장 대표적인 문제는 임계 영역 (Critical Section) 과
 * 데드락 (Deadlock) 이다.
 *
 * 임계 영역 (Critical Section) 이란?
 * - 서로 다른 쓰레드가 같은 자원 (Ex. 변수) 에 동시에 접근해서 작업을 수행하는 현상을 의미한다.
 *
 * 선점형 운영 체제에서는 쓰레드가 CPU 작업 시간을 독점하는 것이 불가능하기 때문에 특정 쓰레드가
 * 작업을 완료하기 전에 CPU 작업 시간이 다른 쓰레드에 넘어가면서 문제가 발생하며 이를 임계 영역이라고 한다.
 *
 * 따라서 서로 다른 쓰레드가 같은 자원에 접근 할 경우 특정 쓰레드가 작업을 완료하기 전에 다른 쓰레드에
 * CPU 작업 시간이 넘어가지 않도록 동기화 처리가 필수다. (+ 즉, 쓰레드가 작업을 완료하는 것을 보장하도록
 * 명령문을 작성해야한다는 것을 알 수 있다.)
 *
 * 데드락 (Deadlock) 이란?
 * - 쓰레드가 특정 자원을 무한히 대기하는 현상을 의미한다. (+ 즉, 쓰레드가 자원을 무한히 기다림으로서
 * 쓰레드가 먹통 된다는 것을 알 수 있다.)
 *
 * 쓰레드가 임계 영역 문제를 해결하기 위해서 주로 사용하는 동기화 처리 방식은 뮤텍스 (Mutex) 와 같은 고유 자원을
 * 활용하는 방법이다.
 *
 * 뮤텍스는 고유 자원 중 하나로서 권한을 획득하는 방식으로 동작한다. (+ 즉, 뮤텍스 권한을 획득함으로서
 * 특정 작업을 처리 할 수 있는 권한을 획득한다는 것을 알 수 있다.)
 *
 * 쓰레드는 뮤텍스의 권한을 획득하고 뮤텍스의 권한을 획득하지 못한 쓰레드는 권한을 획득 할 수 있을 때까지
 * 대기함으로서 임계 영역 문제를 해결하는 것이 가능하다.
 *
 * 이때 뮤텍스의 권한을 획득한 쓰레드는 작업이 완료 되었을 경우 반드시 뮤텍스의 권한을 반납해야한다. (+ 즉,
 * 획득한 뮤텍스의 권한 반납은 해당 뮤텍스를 사용하고 있는 쓰레드에서만 가능하다는 것을 알 수 있다.)
 *
 * 만약 뮤텍스의 권한을 반납하지 않을 경우 다른 쓰레드가 뮤텍스에 대한 권한을 획득하기 위해서 무한히 대기하는
 * 데드락 현상이 발생한다. (+ 즉, 쓰레드가 동작을 멈춘다는 것을 의미한다.)
 */

/**
 * Example 31 (쓰레드)
 */
public class CE01Example_28 {
	/** 초기화 */
	public static void start(String[] args) {
		/*
		 * Thread 클래스란?
		 * - 쓰레드를 제어하기 위한 다양한 기능을 제공하는 클래스를 의미한다. (+ 즉, Thread 클래스를 활용하면
		 * 쓰레드를 중지하는 등의 작업을 처리하는 것이 가능하다.)
		 *
		 * Thread 가 동작하기 위해서는 Thread 를 통해 실행 할 진입 메서드가 필요하다. (+ 즉, 진입 메서드를
		 * 실행하는 쓰레드는 메인 쓰레드가 아니라는 것을 알 수 있다.)
		 *
		 * 쓰레드 진입 메서드는 메인 메서드와 마찬가지로 해당 메서드가 종료 되면 쓰레드도 종료 되는 특징이
		 * 존재한다. (+ 즉, 메인 메서드가 종료 되면 메인 쓰레드가 종료 된다는 것을 알 수 있다.)
		 */
		Thread oThreadA = new Thread(CE01Example_28::main_ThreadA);
		Thread oThreadB = new Thread(CE01Example_28::main_ThreadB);
		
		/*
		 * start 메서드는 쓰레드를 실행 상태로 만드는 역할을 수행한다.
		 *
		 * Java 의 쓰레드는 생성이 완료 되고 나면 바로 동작하는 것이 아니라 실행 가능 상태가 되며
		 * start 메서드를 호출해야 실행 상태가 되어서 동작하는 특징이 존재한다. (+ 즉,
		 * start 메서드를 호출하지 않으면 쓰레드는 실행 되지 않는다는 것을 의미한다.)
		 */
		oThreadA.start();
		oThreadB.start();
		
		try {
			/*
			 * join 메서드는 쓰레드의 종료를 대기하는 역할을 수행한다. (+ 즉, join 메서드를 활용하면
			 * 특정 쓰레드의 작업 완료를 대기하는 것이 가능하다.)
			 *
			 * 쓰레드는 언제든지 CPU 의 작업 시간을 다른 쓰레드에게 빼앗기는 것이 가능하기 때문에
			 * 특정 작업의 완료 여부를 판단하는 것이 중요하며 이때 join 메서드를 활용하면 된다. (+ 즉,
			 * join 메서드를 통해 특정 쓰레드의 종료를 대기 함으로서 해당 쓰레드의 작업 완료 여부를
			 * 대기하는 것이 가능하다.)
			 */
			oThreadA.join();
			oThreadB.join();
		} catch(Exception oException) {
			oException.printStackTrace();
		}
		
		System.out.printf("\n카운트 : %d\n", m_oCounter.getCount());
	}
	
	private static Object m_oKey = new Object();
	private static CCounter m_oCounter = new CCounter();
	
	/** 쓰레드 A 진입 메서드 */
	private static void main_ThreadA() {
		for(int i = 0; i < 1000000; ++i) {
			m_oCounter.incrCount(1);
			System.out.println("쓰레드 A 호출!");
		}
	}
	
	/** 쓰레드 B 진입 메서드 */
	private static void main_ThreadB() {
		for(int i = 0; i < 1000000; ++i) {
			synchronized(m_oKey) {
				m_oCounter.incrCount(1);
			}
			
			System.out.println("쓰레드 B 호출!");
		}
	}
}
